<p>&lt;p align=&quot;center&quot;&gt;
  &lt;a href=&quot;http://liftoffjs.com&quot;&gt;
    &lt;img height=&quot;100&quot; width=&quot;297&quot; src=&quot;https://cdn.rawgit.com/tkellen/js-liftoff/master/artwork/liftoff.svg&quot;/&gt;
  &lt;/a&gt;
&lt;/p&gt;

</p>
<h1 id="liftoff-build-status-https-secure-travis-ci-org-js-cli-js-liftoff-svg-http-travis-ci-org-js-cli-js-liftoff-build-status-https-ci-appveyor-com-api-projects-status-5a6w8xuq8ed1ilc4-branch-master-svg-true-https-ci-appveyor-com-project-js-cli-js-liftoff-branch-master-">liftoff <a href="http://travis-ci.org/js-cli/js-liftoff"><img src="https://secure.travis-ci.org/js-cli/js-liftoff.svg" alt="Build Status"></a> <a href="https://ci.appveyor.com/project/js-cli/js-liftoff/branch/master"><img src="https://ci.appveyor.com/api/projects/status/5a6w8xuq8ed1ilc4/branch/master?svg=true" alt="Build status"></a></h1>
<blockquote>
<p>Launch your command line tool with ease.</p>
</blockquote>
<p><a href="https://nodei.co/npm/liftoff/"><img src="https://nodei.co/npm/liftoff.png" alt="NPM"></a></p>
<h2 id="what-is-it-">What is it?</h2>
<p><a href="http://weblog.bocoup.com/building-command-line-tools-in-node-with-liftoff/">See this blog post</a>, <a href="https://github.com/js-cli/js-hacker">check out this proof of concept</a>, or read on.</p>
<p>Say you’re writing a CLI tool.  Let’s call it <a href="https://github.com/js-cli/js-hacker">hacker</a>.  You want to configure it using a <code>Hackerfile</code>.  This is node, so you install <code>hacker</code> locally for each project you use it in.  But, in order to get the <code>hacker</code> command in your PATH, you also install it globally.</p>
<p>Now, when you run <code>hacker</code>, you want to configure what it does using the <code>Hackerfile</code> in your current directory, and you want it to execute using the local installation of your tool.  Also, it’d be nice if the <code>hacker</code> command was smart enough to traverse up your folders until it finds a <code>Hackerfile</code>&mdash;for those times when you’re not in the root directory of your project.  Heck, you might even want to launch <code>hacker</code> from a folder outside of your project by manually specifying a working directory.  Liftoff manages this for you.</p>
<p>So, everything is working great.  Now you can find your local <code>hacker</code> and <code>Hackerfile</code> with ease.  Unfortunately, it turns out you’ve authored your <code>Hackerfile</code> in coffee-script, or some other JS variant.  In order to support <em>that</em>, you have to load the compiler for it, and then register the extension for it with node.  Good news, Liftoff can do that, and a whole lot more, too.</p>
<h2 id="api">API</h2>
<h3 id="constructor-opts-">constructor(opts)</h3>
<p>Create an instance of Liftoff to invoke your application.</p>
<p>An example utilizing all options:</p>
<pre><code class="lang-js">const Hacker = new Liftoff({
  name: &#39;hacker&#39;,
  processTitle: &#39;hacker&#39;,
  moduleName: &#39;hacker&#39;,
  configName: &#39;hackerfile&#39;,
  extensions: {
    &#39;.js&#39;: null,
    &#39;.json&#39;: null,
    &#39;.coffee&#39;: &#39;coffee-script/register&#39;
  },
  v8flags: [&#39;--harmony&#39;] // or v8flags: require(&#39;v8flags&#39;)
});
</code></pre>
<h4 id="opts-name">opts.name</h4>
<p>Sugar for setting <code>processTitle</code>, <code>moduleName</code>, <code>configName</code> automatically.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<p>These are equivalent:</p>
<pre><code class="lang-js">const Hacker = Liftoff({
  processTitle: &#39;hacker&#39;,
  moduleName: &#39;hacker&#39;,
  configName: &#39;hackerfile&#39;
});
</code></pre>
<pre><code class="lang-js">const Hacker = Liftoff({name:&#39;hacker&#39;});
</code></pre>
<h4 id="opts-modulename">opts.moduleName</h4>
<p>Sets which module your application expects to find locally when being run.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-configname">opts.configName</h4>
<p>Sets the name of the configuration file Liftoff will attempt to find.  Case-insensitive.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-extensions">opts.extensions</h4>
<p>Set extensions to include when searching for a configuration file.  If an external module is needed to load a given extension (e.g. <code>.coffee</code>), the module name should be specified as the value for the key.</p>
<p>Type: <code>Object</code><br>Default: <code>{&quot;.js&quot;:null,&quot;.json&quot;:null}</code></p>
<p><strong>Examples:</strong></p>
<p>In this example Liftoff will look for <code>myappfile{.js,.json,.coffee}</code>.  If a config with the extension <code>.coffee</code> is found, Liftoff will try to require <code>coffee-script/require</code> from the current working directory.</p>
<pre><code class="lang-js">const MyApp = new Liftoff({
  name: &#39;myapp&#39;,
  extensions: {
    &#39;.js&#39;: null,
    &#39;.json&#39;: null,
    &#39;.coffee&#39;: &#39;coffee-script/register&#39;
  }
});
</code></pre>
<p>In this example, Liftoff will look for <code>.myapp{rc}</code>.</p>
<pre><code class="lang-js">const MyApp = new Liftoff({
  name: &#39;myapp&#39;,
  configName: &#39;.myapp&#39;,
  extensions: {
    &#39;rc&#39;: null
  }
});
</code></pre>
<p>In this example, Liftoff will automatically attempt to load the correct module for any javascript variant supported by <a href="https://github.com/tkellen/node-interpret">node-interpret</a> (as long as it does not require a register method).</p>
<pre><code class="lang-js">const MyApp = new Liftoff({
  name: &#39;myapp&#39;,
  extensions: require(&#39;interpret&#39;).jsVariants
});
</code></pre>
<h4 id="opts-v8flags">opts.v8flags</h4>
<p>Any flag specified here will be applied to node, not your program.  Useful for supporting invocations like <code>myapp --harmony command</code>, where <code>--harmony</code> should be passed to node, not your program. This functionality is implemented using <a href="http://github.com/tkellen/node-flagged-respawn">flagged-respawn</a>. To support all v8flags, see <a href="https://github.com/tkellen/node-v8flags">node-v8flags</a>.</p>
<p>Type: <code>Array|Function</code><br>Default: <code>null</code></p>
<p>If this method is a function, it should take a node-style callback that yields an array of flags.</p>
<h4 id="opts-processtitle">opts.processTitle</h4>
<p>Sets what the <a href="http://nodejs.org/api/process.html#process_process_title">process title</a> will be.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-completions-type-">opts.completions(type)</h4>
<p>A method to handle bash/zsh/whatever completions.</p>
<p>Type: <code>Function</code><br>Default: <code>null</code></p>
<h2 id="launch-opts-callback-env-">launch(opts, callback(env))</h2>
<p>Launches your application with provided options, builds an environment, and invokes your callback, passing the calculated environment as the first argument.</p>
<h5 id="example-configuration-w-options-parsing-">Example Configuration w/ Options Parsing:</h5>
<pre><code class="lang-js">const Liftoff = require(&#39;liftoff&#39;);
const MyApp = new Liftoff({name:&#39;myapp&#39;});
const argv = require(&#39;minimist&#39;)(process.argv.slice(2));
const invoke = function (env) {
  console.log(&#39;my environment is:&#39;, env);
  console.log(&#39;my cli options are:&#39;, argv);
  console.log(&#39;my liftoff config is:&#39;, this);
};
MyApp.launch({
  cwd: argv.cwd,
  configPath: argv.myappfile,
  require: argv.require,
  completion: argv.completion
}, invoke);
</code></pre>
<h4 id="opts-cwd">opts.cwd</h4>
<p>Change the current working directory for this launch. Relative paths are calculated against <code>process.cwd()</code>.</p>
<p>Type: <code>String</code><br>Default: <code>process.cwd()</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="lang-js">const argv = require(&#39;minimist&#39;)(process.argv.slice(2));
MyApp.launch({
  cwd: argv.cwd
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code>myapp --cwd ../
</code></pre><h4 id="opts-configpath">opts.configPath</h4>
<p>Don’t search for a config, use the one provided. <strong>Note:</strong> Liftoff will assume the current working directory is the directory containing the config file unless an alternate location is explicitly specified using <code>cwd</code>.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="lang-js">var argv = require(&#39;minimist&#39;)(process.argv.slice(2));
MyApp.launch({
  configPath: argv.myappfile
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code>myapp --myappfile /var/www/project/Myappfile.js
</code></pre><p><strong>Examples using <code>cwd</code> and <code>configPath</code> together:</strong></p>
<p>These are functionally identical:</p>
<pre><code>myapp --myappfile /var/www/project/Myappfile.js
myapp --cwd /var/www/project
</code></pre><p>These can run myapp from a shared directory as though it were located in another project:</p>
<pre><code>myapp --myappfile /Users/name/Myappfile.js --cwd /var/www/project1
myapp --myappfile /Users/name/Myappfile.js --cwd /var/www/project2
</code></pre><h4 id="opts-require">opts.require</h4>
<p>A string or array of modules to attempt requiring from the local working directory before invoking the launch callback.</p>
<p>Type: <code>String|Array</code><br>Default: <code>null</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="lang-js">var argv = require(&#39;minimist&#39;)(process.argv.slice(2));
MyApp.launch({
  require: argv.require
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code class="lang-js">myapp --require coffee-script/register
</code></pre>
<h4 id="callback-env-">callback(env)</h4>
<p>A function to start your application.  When invoked, <code>this</code> will be your instance of Liftoff. The <code>env</code> param will contain the following keys:</p>
<ul>
<li><code>cwd</code>: the current working directory</li>
<li><code>require</code>: an array of modules that liftoff tried to pre-load</li>
<li><code>configNameSearch</code>: the config files searched for</li>
<li><code>configPath</code>: the full path to your configuration file (if found)</li>
<li><code>configBase</code>: the base directory of your configuration file (if found)</li>
<li><code>modulePath</code>: the full path to the local module your project relies on (if found)</li>
<li><code>modulePackage</code>: the contents of the local module’s package.json (if found)</li>
</ul>
<h3 id="events">events</h3>
<h4 id="require-name-module-">require(name, module)</h4>
<p>Emitted when a module is pre-loaded.</p>
<pre><code class="lang-js">var Hacker = new Liftoff({name:&#39;hacker&#39;});
Hacker.on(&#39;require&#39;, function (name, module) {
  console.log(&#39;Requiring external module: &#39;+name+&#39;...&#39;);
  // automatically register coffee-script extensions
  if (name === &#39;coffee-script&#39;) {
    module.register();
  }
});
</code></pre>
<h4 id="requirefail-name-err-">requireFail(name, err)</h4>
<p>Emitted when a requested module cannot be preloaded.</p>
<pre><code class="lang-js">var Hacker = new Liftoff({name:&#39;hacker&#39;});
Hacker.on(&#39;requireFail&#39;, function (name, err) {
  console.log(&#39;Unable to load:&#39;, name, err);
});
</code></pre>
<h4 id="respawn-flags-child-">respawn(flags, child)</h4>
<p>Emitted when Liftoff re-spawns your process (when a <a href="#optsnodeflags"><code>nodeFlag</code></a> is detected).</p>
<pre><code class="lang-js">var Hacker = new Liftoff({
  name: &#39;hacker&#39;,
  nodeFlags: [&#39;--harmony&#39;]
});
Hacker.on(&#39;respawn&#39;, function (flags, child) {
  console.log(&#39;Detected node flags:&#39;, flags);
  console.log(&#39;Respawned to PID:&#39;, child.pid);
});
</code></pre>
<p>Event will be triggered for this command:
<code>hacker --harmony commmand</code></p>
<h2 id="examples">Examples</h2>
<p>Check out how <a href="https://github.com/gulpjs/gulp/blob/master/bin/gulp.js">gulp</a> uses Liftoff.</p>
<p>For a bare-bones example, try <a href="https://github.com/js-cli/js-hacker/blob/master/bin/hacker.js">the hacker project</a>.</p>
<p>To try the example, do the following:</p>
<ol>
<li>Install the sample project <code>hacker</code> with <code>npm install -g hacker</code>.</li>
<li>Make a <code>Hackerfile.js</code> with some arbitrary javascript it.</li>
<li>Install hacker next to it with <code>npm install hacker</code>.</li>
<li>Run <code>hacker</code> while in the same parent folder.</li>
</ol>
